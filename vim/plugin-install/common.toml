[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'vim-jp/vimdoc-ja'
hook_add = '''
set helplang=ja
'''

[[plugins]]
repo = 'LumaKernel/open-browser.vim'
rev = 'support_wsl2'
hook_add = '''
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)
'''


[[plugins]]
repo = 'jacoborus/tender.vim'
[[plugins]]
repo = 'cocopon/iceberg.vim'
[[plugins]]
repo = 'joshdick/onedark.vim'
hook_add = 'let g:switch_color_scheme_default = "onedark"'
[[plugins]]
repo = 'rhysd/vim-color-spring-night'
[[plugins]]
repo = 'dracula/vim'
name = 'colorscheme-dracula-vim'
[[plugins]]
repo = 'jpo/vim-railscasts-theme'
[[plugins]]
repo = 'junegunn/seoul256.vim'
[[plugins]]
repo = 'fcpg/vim-orbital'
[[plugins]]
repo = 'drewtempelmeyer/palenight.vim'
[[plugins]]
repo = 'AlessandroYorba/Sierra'
[[plugins]]
repo = 'NLKNguyen/papercolor-theme'
[[plugins]]
repo = 'cormacrelf/vim-colors-github'
[[plugins]]
repo = 'bluz71/vim-nightfly-guicolors'
[[plugins]]
repo = 'mhartington/oceanic-next'
[[plugins]]
repo = 'glepnir/zephyr-nvim'
[[plugins]]
if = 'has("nvim")'
repo = 'tjdevries/colorbuddy.vim'
[[plugins]]
repo = 'sainnhe/edge'

[[plugins]]
repo = 'itchyny/vim-gitbranch'
if = "has('patch-8.2.0001') || has('nvim')"
[[plugins]]
repo = 'itchyny/lightline.vim'
if = "has('patch-8.2.0001') || has('nvim')"
depends = []
hook_add = '''
let g:lightline = {
  \   'colorscheme': 'seoul256',
  \   'active': {
  \     'left':  [
  \       [ 'mode', 'paste' ],
  \       [ 'gitbranch', 'filename', 'filestat', 'modified', 'readonly' ],
  \       [ 'charvaluehex' ],
  \     ],
  \     'right': [
  \       [ 'lineinfo' ],
  \       [ 'fileformat', 'fileencoding', 'filetype' ],
  \     ],
  \   },
  \   'inactive': {
  \     'left':  [
  \       [ 'gitbranch', 'filename', 'filestat', 'modified', 'readonly' ],
  \     ],
  \     'right': [
  \       [ 'lineinfo' ],
  \       [ 'fileformat', 'fileencoding', 'filetype' ],
  \     ],
  \   },
  \   'component': {
  \     'charvaluehex': '0x%B',
  \   },
  \   'component_function': {
  \     'mode': 'MyMode',
  \     'gitbranch': 'MyGitBrnach',
  \     'readonly': 'MyReadonly',
  \     'filename': 'MyFilename',
  \     'filestat': 'MyFilestat',
  \     'modified': 'MyModified',
  \     'fileformat': 'MyFileformat',
  \   },
  \ }

function! MyGitBrnach()
  if &buftype is# 'help'
    return ''
  elseif !empty(getcmdwintype())
    return ''
  elseif &filetype is# 'fern'
    return ''
  endif
  let res = gitbranch#name()
  if empty(res)
    return 'no git'
  endif
  return printf('git:%s', res)
endfunction

function! MyReadonly()
  if &buftype is# 'help'
    return ''
  elseif !empty(getcmdwintype())
    return ''
  elseif &filetype is# 'fern'
    return ''
  endif
  return &ro is# 1 ? 'RO' : ''
endfunction

function! MyFilename()
  if &buftype is# 'help'
    return ''
  elseif &filetype is# 'fern'
    return ''
  endif
  return expand('%:t')
endfunction

if executable('stat')
  let g:MyStatCache = {}
  function! MyFilestat()
    let filename = g:MyGetFilename()

    if empty(filename)
      return filename
    endif

    if has_key(g:MyStatCache, filename)
      return g:MyStatCache[filename]
    endif

    let res = ''
    silent! let res = trim(
      \   system(printf("stat --format '%%a' %s", shellescape(filename)))
      \ )
    if match(res, '^\d\d\d$') == -1
      return ''
    endif
    let g:MyStatCache[filename] = res
    return res
  endfunction

  function! MyStatCacheDeleteThis()
    let filename = g:MyGetFilename()

    if empty(filename)
      return filename
    endif

    silent! unlet! g:MyStatCache[filename]
  endfunction

  function! MyGetFilename()
    if &buftype is# 'help'
      return ''
    elseif !empty(getcmdwintype())
      return ''
    elseif &filetype is# 'fern'
      let filename = GetFernDirname()
    else
      let filename = expand('%:p')
    endif

    return filename
  endfunction

  augroup MyStatCache
    autocmd BufEnter * call g:MyStatCacheDeleteThis()
  augroup END
else
  function! MyFilestat()
    return ''
  endfunction
endif

function! MyMode()
  if &buftype is# 'help'
    return ''
  elseif !empty(getcmdwintype())
    return ''
  elseif &filetype is# 'fern'
    return GetFernDirname()
  endif
  return toupper(mode())
endfunction

function! MyFileformat()
  if &buftype is# 'help'
    return ''
  elseif !empty(getcmdwintype())
    return ''
  elseif &filetype is# 'fern'
    return GetFernDirname()
  endif

  if &ff is# 'dos'
    return '\r\n'
  elseif &ff is# 'unix'
    return '\n'
  elseif &ff is# 'mac'
    return '\r'
  endif
  return ''
endfunction

function! MyModified()
  if &buftype is# 'help'
    return ''
  elseif !empty(getcmdwintype())
    return ''
  elseif &filetype is# 'fern'
    return ''
  endif

  return &modified is# 1 ? '*' : ''
endfunction

function! GetFernDirname()
  let path = get(matchlist(expand('%'), 'fern://[^/]\+/file://\(.*\)\$'), 1, '')
  return path
endfunction
'''

[[plugins]]
repo = 'itchyny/vim-cursorword'
if = '!g:from_pwsh && !has("nvim")'

[[plugins]]
repo = 'RRethy/vim-illuminate'

[[plugins]]
if = 0
repo = 'tyru/caw.vim'

[[plugins]]
repo = 'lambdalisue/fern.vim'
hook_add = '''
let g:fern#profile = 0
let g:fern#disable_viewer_auto_duplication = 1
let s:fern_default_exclude_pats = [
  \   '^\.git$',
  \   '^\.DS_Store$',
  \   '^node_modules$',
  \   '^dist$',
  \   '^:Zone\.Identifier$',
  \   '^__pycache__$',
  \   '^yarn.lock$',
  \   '^package-lock.json$',
  \ ]

function! s:GetFernExclude() abort
  let ignore_pats = copy(s:fern_default_exclude_pats)
  return join(ignore_pats, '\|')
endfunction


let g:fern#default_hidden = 1
let g:fern#default_exclude = s:GetFernExclude()

function! s:init_fern() abort
  silent! nunmap <buffer> t
endfunction

function! FernRevealPwdOrThere() abort
  if !filereadable(expand('%'))
    Fern .
    return ''
  endif
  let F = vital#vital#import('System.Filepath')
  " XXX: VCS まで登ってもいいかも
  let dir = expand('%:p:h')
  if F.contains(dir, getcwd())
    let dir = getcwd()
  endif
  exe printf('Fern %s -reveal=%%', dir)
  return ''
endfunction

function! s:fern_default() abort
  let exclude_save = g:fern#default_exclude
  let g:fern#default_exclude = s:GetFernExclude()
  call FernRevealPwdOrThere()
  let g:fern#default_exclude = exclude_save
endfunction

function! s:fern_all() abort
  let exclude_save = g:fern#default_exclude
  let g:fern#default_exclude = ''
  call FernRevealPwdOrThere()
  let g:fern#default_exclude = exclude_save
endfunction

nnoremap <silent> <Leader>ai :<C-u>call <SID>fern_default()<CR>
nnoremap <silent> <Leader>aa :<C-u>call <SID>fern_all()<CR>

augroup my-fern
  autocmd! *
  " autocmd FileType fern call s:init_fern()
augroup END

let g:loaded_netrw             = 1
let g:loaded_netrwPlugin       = 1
let g:loaded_netrwSettings     = 1
let g:loaded_netrwFileHandlers = 1

augroup my-fern-hijack
  autocmd!
  autocmd BufEnter * ++nested call s:hijack_directory()
augroup END

function! s:hijack_directory() abort
  let path = expand('%')
  if !isdirectory(path)
    return
  endif
  exe 'Fern' path
endfunction
'''

# [[plugins]]
# repo = 'lambdalisue/fern-git-status.vim'
# depends = 'fern.vim'
# hook_add = '''
#   let g:fern_git_status#disable_untracked = 1
# '''
# 
# [[plugins]]
# repo = 'lambdalisue/fern-mapping-git.vim'
# depends = 'fern.vim'


[[plugins]]
repo = 'Shougo/deoppet.nvim'
if = 'has("nvim")'
hook_post_source = '''
call deoppet#initialize()
call deoppet#custom#option(
  \   'snippets',
  \   [{'path':expand('~/dotfiles/vim/snippets/')}],
  \ )

imap <expr><C-k>
  \ deoppet#expandable()
  \ ? "\<Plug>(deoppet_expand)"
  \ : "\<Plug>(deoppet_jump_backward)"
imap <C-b> <Plug>(deoppet_jump_backward)
smap <C-k> <Plug>(deoppet_jump_forward)
smap <C-b> <Plug>(deoppet_jump_backward)

" XXX: without silent! it rases error...
silent! function! EditSnippet() abort
  let snip_path = expand(printf('~/dotfiles/vim/snippets/%s.snip', &l:filetype))
  execute 'edit' fnameescape(snip_path)
endfunction

command! -bar EditSnippet call EditSnippet()
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'

[[plugins]]
repo = 't9md/vim-choosewin'
hook_add = '''
nnoremap <Leader>cw :<C-u>ChooseWin<CR>
nnoremap <Leader>cs :<C-u>ChooseWinSwap<CR>
'''


[[plugins]]
repo = 'junegunn/fzf'
merged = 0
build = './install --all'

[[plugins]]
repo = 'junegunn/fzf.vim'
depends = 'fzf'
hook_add = '''
if has('win32')
  " Windows: preview は相性があまりよくない
  "   UTF-8 と CP932 を両方見れるようにするのがまず難しいそう
  let $FZF_DEFAULT_OPTS = '--tabstop=4'
else
  let file_viewer = 'cat {} 2>/dev/null'
  let dir_viewer = 'ls {}'
  if executable('bat')
    let file_viewer = 'bat --pager=never --color=always --style=numbers {} 2>/dev/null'
  endif
  if executable('exa')
    let dir_viewer = 'exa --tree --color always {}'
  endif
  let $FZF_DEFAULT_OPTS = printf('--tabstop=4 --preview-window hidden:up --preview "%s || %s"', file_viewer, dir_viewer)
endif

if executable('ag') && $FZF_DEFAULT_COMMAND ==# ''
  let $FZF_DEFAULT_COMMAND='ag --hidden --ignore .git -g ""'
endif

if has('nvim')
  let g:fzf_layout = { 'window': 'call my#CreateCenteredFloatingWindow()' }
endif

command! -bang Colors call fzf#vim#colors({'options': '--preview ""'}, <bang>0)


function! RipgrepFzf(query, fullscreen) abort
  let command_fmt = 'rg --hidden --column --line-number --no-heading --color=always --smart-case -- %s || true'
  let initial_command = printf(command_fmt, shellescape(a:query))
  let reload_command = printf(command_fmt, '{q}')
  let spec = {'options': [
    \   '--preview-window', 'hidden:up:noborder',
    \   '--phony',
    \   '--query', a:query,
    \   '--bind', 'change:reload:'.reload_command
    \ ]}
  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
endfunction

command! -nargs=* -bang Rg call RipgrepFzf(<q-args>, <bang>0)


nnoremap <silent> ,f  :<C-u>Files<CR>
nnoremap <silent> ,df :<C-u>GFiles<CR>
nnoremap <silent> ,dd :<C-u>GFiles?<CR>
nnoremap <silent><expr> ,cf ':<C-u>Files<CR>' .. expand('<cfile>')
nnoremap <silent><expr> ,cdf ':<C-u>GFiles<CR>' .. expand('<cword>')
nnoremap <silent><expr> ,cdd ':<C-u>GFiles?<CR>' .. expand('<cword>')
nnoremap <silent> <Leader>i :<C-u>History<CR>
nnoremap <silent> <Leader>ls :<C-u>Buffers<CR>
nnoremap <silent> <Leader>col :<C-u>Colors<CR>

function! s:RgPrompt() abort
  call inputsave()
  let str = input("Rg > ")
  call inputrestore()
  if !empty(str)
    execute printf('Rg %s', str)
  endif
endfunction

function! s:RgLiterallyPrompt() abort
  call inputsave()
  let str = input("Rg Literally > ")
  call inputrestore()
  if !empty(str)
    call s:RgLiterally(str)
  endif
endfunction

function! s:RgLiterally(str) abort
  let literal = a:str

  let regex = Regex7Escape(literal)
  let regex = substitute(regex, '[\n\r]', '[\s\S]?', 'g')
  let regex = substitute(regex, '\t', '\\t', 'g')

  execute printf('Rg %s', regex)
endfunction

function! s:RgLiterallySelected() abort
  let yank_save = @@
  normal! gvy
  let copied = @@
  let @@ = yank_save

  call s:RgLiterally(copied)
endfunction

nnoremap <expr><silent> ,cg ':call <SID>RgLiterally(expand("<cword>"))<CR>'
nnoremap ,g :<C-u>call <SID>RgPrompt()<CR>
nnoremap ,rg :<C-u>call <SID>RgLiterallyPrompt()<CR>
xnoremap ,g :<C-u>call <SID>RgLiterallySelected()<CR>
xnoremap ,cg :<C-u>call <SID>RgLiterllySelected()<CR>
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
hook_add = '''
let g:quickrun_config = get(g:, 'quickrun_config', {})
let g:quickrun_config['_'] = {
    \   'outputter' : 'quickfix',
    \   'runner' : has('+job') ? 'job' : 'vimproc'
    \ }
nnoremap <expr> <Leader>0 ":ccl\|QuickRun\<CR>"
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
'''

[[plugins]]
repo = 'Shougo/vimproc.vim'
build = 'make'

[[plugins]]
repo = 'lambdalisue/gina.vim'
hook_post_source = '''
" -- status の設定
call gina#custom#command#alias('status', 's')
call gina#custom#command#option('s', '--short')

call gina#custom#command#alias('log', 'lg')
call gina#custom#command#option('lg', '--graph')

nnoremap <silent> <Leader>st :<C-u>Gina s<CR>
nnoremap <silent> <Leader>cc :<C-u>Gina compare<CR>
nnoremap <silent> <Leader>com :<C-u>tabnew \| Gina commit<CR>:split \| Gina diff --cached<CR>:wincmd w<CR>
nnoremap <silent> <Leader>dd :<C-u>Gina diff HEAD<CR>
nnoremap <silent> <Leader>lg :<C-u>Gina lg<CR>
nnoremap <silent> <Leader>bla :<C-u>Gina blame<CR>

function! s:Browse(line1, line2) abort
  let save = @@
  let @@ = ''
  if filereadable(expand('%'))
    execute printf('%d,%dGina browse --yank :', a:line1, a:line2)
  else
    Gina browse --yank
  endif
  if !empty(@@)
    execute "OpenBrowser" @@
  endif
  let @@ = save
endfunction

command! -range Browse call <SID>Browse(<line1>, <line2>)
command! -range GitHubBrowse call <SID>Borwse(<line1>, <line2>)
nnoremap <silent> <Leader>bro :Browse<CR>
xnoremap <silent> <Leader>bro :Browse<CR>
'''


[[plugins]]
repo = 'haya14busa/vim-asterisk'
hook_add = '''
let g:asterisk#keeppos = 1
map *  <Plug>(asterisk-z*)
map #  <Plug>(asterisk-z*)N
map g* <Plug>(asterisk-gz*)
map g# <Plug>(asterisk-gz*)N
xmap *  <Plug>(asterisk-z*)
xmap #  <Plug>(asterisk-z*)N
xmap g* <Plug>(asterisk-gz*)
xmap g# <Plug>(asterisk-gz*)N
'''

[[plugins]]
repo = 'junegunn/vim-easy-align'
hook_add = '''
xmap ga <Plug>(LiveEasyAlign)
nmap ga <Plug>(LiveEasyAlign)
'''

[[plugins]]
repo = 'HiPhish/info.vim'

[[plugins]]
repo = 'mattn/emmet-vim'
# for preact
# let g:user_emmet_settings = emmet#merge(get(g:, 'user_emmet_settings'), { 'jsx': { 'attribute_name': {'class': 'class'}}})
hook_add = '''
  let g:user_emmet_leader_key = "\<C-f>"
'''

[[plugins]]
repo = 'editorconfig/editorconfig-vim'

[[plugins]]
repo = 'machakann/vim-sandwich'
# [s]urround ([a]dd/[d]elete/[r]ename)
# [i]nner [b]races
# [a] [b]raced text

[[plugins]]
repo = 'AndrewRadev/splitjoin.vim'
# gS : split
# gJ : join

[[plugins]]
repo = 'rhysd/conflict-marker.vim'
# [x, ]x : jumps

[[plugins]]
repo = 'rhysd/accelerated-jk'
# 重いときに j/k を叩きまくった後の硬直を緩和してくれる
hook_add = '''
nmap j <Plug>(accelerated_jk_gj)
nmap k <Plug>(accelerated_jk_gk)
nmap gj <Plug>(accelerated_jk_j)
nmap gk <Plug>(accelerated_jk_k)
'''

[[plugins]]
repo = 'HerringtonDarkholme/yats.vim'
if = '!has("nvim")'
on_ft = ["typescript", "typescriptreact"]

[[plugins]]
repo = 'othree/yajs.vim'
if = '!has("nvim")'
on_ft = ["javascript", "typescript", "javascriptreact", "typescriptreact"]

[[plugins]]
repo = 'rhysd/committia.vim'
hook_add = '''
let g:committia_hooks = {}
function! g:committia_hooks.edit_open(info)
  " Additional settings
  setlocal spell

  " If no commit message, start with insert mode
  if a:info.vcs ==# 'git' && getline(1) ==# ''
    startinsert
  endif

  " Scroll the diff window from insert mode
  " Map <C-n> and <C-p>
  imap <buffer><C-n> <Plug>(committia-scroll-diff-down-half)
  imap <buffer><C-p> <Plug>(committia-scroll-diff-up-half)
endfunction
'''

[[plugins]]
repo = 'rhysd/vim-gfm-syntax'
on_ft = "markdown"
# GitHub Favored Markdown Syntax

[[plugins]]
repo = 'LumaKernel/fern-mapping-fzf.vim'
rev="feat-root"
depends = ['fzf', 'fern.vim']
hook_add = '''
function! Fern_mapping_fzf_customize_option(spec)
  let a:spec.options .= ' --multi'
  return fzf#vim#with_preview(a:spec)
endfunction

function! Fern_mapping_fzf_before_all(dict)
  if !len(a:dict.lines)
    return
  endif
  return a:dict.fern_helper.async.update_marks([])
endfunction

function! s:reveal(dict)
  execute "FernReveal -wait" a:dict.relative_path
  if len(a:dict.lines) > 2
    execute "normal \<Plug>(fern-action-mark:set)"
  endif
endfunction

let g:Fern_mapping_fzf_file_sink = function('s:reveal')
let g:Fern_mapping_fzf_dir_sink = function('s:reveal')
'''

[[plugins]]
repo = 'LumaKernel/fern-mapping-reload-all.vim'
depends = ['fern.vim']
hook_add = '''
function! s:init_fern_mapping_reload_all() abort
  nmap <buffer> R <Plug>(fern-action-reload:all)
endfunction
augroup my-fern-mapping-reload-all
  autocmd! *
  autocmd FileType fern call s:init_fern_mapping_reload_all()
augroup END
'''

[[plugins]]
repo = 'LumaKernel/vim-zenspace'

[[plugins]]
repo = 'LumaKernel/vim-messages-qf'
meged = 0
hook_add = '''
command! -bar MessagesQF call g:messages_qf#messages() | Cedit
'''

[[plugins]]
repo = 'othree/html5.vim'
on_ft = ['html', 'htmldjango']

[[plugins]]
repo = 'LumaKernel/vim-jsx-pretty'

[[plugins]]
repo = 'kana/vim-altr'
# call altr#define('src/%.css', 'dist/%.css')
hook_add = '''
nmap <SPACE>ap <Plug>(altr-back)
nmap <SPACE>an <Plug>(altr-forward)
'''

[[plugins]]
repo = 'thinca/vim-localrc'
hook_add = '''
  let g:localrc_filename = 'local_init.vim'
'''

[[plugins]]
repo = 'vim-python/python-syntax'
on_ft = 'python'
hook_add = '''
  let g:python_highlight_all = 1
'''

[[plugins]]
repo = 'LumaKernel/vim-goimports'
on_ft = 'go'
hook_add = '''
let g:goimports_simplify = 1
let g:goimports_loclist = 0
'''

[[plugins]]
repo = 'lambdalisue/vim-findent'
hook_add = '''
silent! EditorConfigDisable

function! s:my_findent_init() abort
  let no_check = [
    \   'javascript',
    \   'typescript',
    \   'typescriptreact',
    \ ]
  if index(no_check, &l:ft) < 0
    Findent --no-messages --no-warnings --chunksize=300
    call timer_start(0, {-> execute("silent! EditorConfigReload")})
  endif
endfunction

augroup findent
  autocmd!
  autocmd BufNewFile,BufReadPost,BufFilePost * call s:my_findent_init()
augroup END
'''

[[plugins]]
if = "has('nvim')"
repo = 'norcalli/nvim-colorizer.lua'
hook_post_source = '''
lua require'colorizer'.setup()
'''

# Lang: C++
[[plugins]]
repo = 'Mizuchi/STL-Syntax'
[[plugins]]
repo = 'rhysd/wandbox-vim'

# Lang: OCaml
[[plugins]]
repo = 'ocaml/vim-ocaml'
on_ft = 'ocaml'
[[plugins]]
repo = 'let-def/ocp-indent-vim'

# Lang: Fish
[[plugins]]
repo = 'dag/vim-fish'

# Lang: Django
[[plugins]]
repo = 'tweekmonster/django-plus.vim'

# Lang: JavaScript
[[plugins]]
repo = 'heavenshell/vim-jsdoc'
hook_add = '''
let g:jsdoc_enable_es6 = 1
au FileType javascript nnoremap <buffer> <Leader>d :JsDoc
'''

# Lang: TOML
[[plugins]]
repo = 'cespare/vim-toml'

# Lang: Vim
[[plugins]]
repo = 'vim-jp/vital.vim'
merged = 0
[[plugins]]
repo = 'haya14busa/vital-vimlcompiler'
[[plugins]]
repo = 'haya14busa/vital-power-assert'
depends = ["vital.vim"]
hook_add = '''
let g:__vital_power_assert_config = {
  \   '__debug__': 1
  \ }
'''
[[plugins]]
repo = 'haya14busa/vital-safe-string'
[[plugins]]
repo = 'lambdalisue/vital-Whisky'
[[plugins]]
repo = 'thinca/vim-themis'
hook_add = '''
if !executable('themis')
  if has('win32')
    let $PATH ..= ';' .. expand('~') .. '/.cache/dein/repos/github.com/thinca/vim-themis/bin'
  else
    let $PATH ..= ':' .. expand('~') .. '/.cache/dein/repos/github.com/thinca/vim-themis/bin'
  endif
endif
'''

# Lang: JSON
[[plugins]]
repo = 'elzr/vim-json'
hook_add = '''
  let g:vim_json_syntax_conceal = 0
'''
[[plugins]]
repo = 'neoclide/jsonc.vim'

# Lang: PowerShell
[[plugins]]
repo = 'PProvost/vim-ps1'

# Lang: Q#
[[plugins]]
repo = 'gootorov/q-sharp.vim'

# Lang: Coq
[[plugins]]
repo = "LumaKernel/coqpit.vim"
on_ft = "coq"
hook_source = '''
let g:coqpit_auto_move=1
let g:coqpit_one_window=0

function! MyCoqMaps()
  nnoremap <silent> <C-C> :CoqLaunch<CR>
  nnoremap <silent> <Leader>j :CoqNext<CR>
  nnoremap <silent> <Leader>k :CoqBack<CR>
  nnoremap <silent> <Leader>l :CoqToCursor<CR>
  nnoremap <silent> <Leader>g :CoqToLast<CR>
  nnoremap <silent> <Leader>t :MoveToTop<CR>

  nnoremap <Leader>compute :CoqQuery Compute .<Left>
  nnoremap <Leader>print :CoqQuery Print .<Left>
  nnoremap <Leader>check :CoqQuery Check .<Left>
  nnoremap <Leader>search :CoqQuery Search ().<Left><Left>
endfunction

augroup my-coq
  au!
  au FileType coq :call MyCoqMaps()
augroup END

if has('win32')
  let g:coqpit_coq_executable = 'C:\Coq8.10\bin\coqidetop.exe'
elseif has('unix')
  let g:coqpit_coq_executable = expand('~/.local/bin/coq/V8.11.1/bin/coqidetop')
endif

function! CoqSwitchStyle() abort
  if !exists('b:coquilleIDE') || b:coquilleIDE.dead()
    return
  endif

  let b:coquilleIDE.my_style = !get(b:coquilleIDE, 'my_style', 0)
  if b:coquilleIDE.my_style
    let b:coquilleIDE.style_checked = 'last_line'
    let b:coquilleIDE.style_queued  = 'last_line'
  else
    let b:coquilleIDE.style_checked = 'all'
    let b:coquilleIDE.style_queued  = 'all'
  endif
  CoqRecolor
endfunction

command! CoqSwitchStyle call CoqSwitchStyle()
'''

# --------------

# Startify
[[plugins]]
repo = 'mhinz/vim-startify'
hook_add = '''
function! s:repeat(str, num)
  return join(map(range(a:num), 'a:str'), '')
endfunction

let g:my_startify_message = [
      \   "\uf120  Welcome to \ue7c5 !",
      \ ]

let g:startify_enable_special = 0
let g:startify_session_dir = '~/.tmp/vim/startify-session'

let g:startify_custom_header = 'startify#pad(g:my_startify_message)'

" .git とか (VCS) が見つかるまで上に登って change directory する
let g:startify_change_to_dir = 1
let g:startify_change_to_vcs_root = 1


" 最新の状態にする
let g:startify_update_oldfiles = 0

let g:startify_session_persistence = 1

let g:startify_bookmarks = [
      \   '~/cp',
      \   '~/mynote',
      \   '~/work',
      \   '~/dotfiles',
      \   '~/vim-make-plugin',
      \   '~/.cache/dein/repos',
      \ ]

function! s:MyColorSelections()
  let names = getcompletion('', 'color')
  let excludes = [
      \   'blue',
      \   'default',
      \   'delek',
      \   'elflord',
      \   'evening',
      \   'industry',
      \   'koehler',
      \   'morning',
      \   'murphy',
      \   'pablo',
      \   'peachpuff',
      \   'ron',
      \   'shine',
      \   'slate',
      \   'torte',
      \   'zellner',
      \ ]

  call filter(names, {_, name -> index(excludes, name) < 0})
  return map(copy(names), {_, colo -> {'line': colo, 'cmd': printf('SwitchColorScheme %s', colo)}})
endfunction

function! s:MyRefs()
  return [
        \   { 'line': 'GNU Make' , 'cmd': 'call LynxCache("https://www.gnu.org/software/make/manual/make.html")' },
        \ ]
endfunction

function! g:LynxCache(url) abort
  let URI = vital#vital#import('Web.URI')
  let HTTP = vital#vital#import('Web.HTTP')
  let filename = expand('~/docs') .. '/' .. URI.encode(a:url)
  call mkdir(fnamemodify(filename, ':h'), 'p')
  try
    if !filereadable(filename)
      call HTTP.request({'url': a:url, 'method': 'GET', 'outputFile': filename})
    endif
  catch /.*/
    echom '[LynxCache] Something wrong. Couldn''t make cache.'
    exe 'Ref lynx' a:url
    return
  endtry
  exe 'Ref lynx' filename
endfunction

function! s:MyLinks()
  let l:res = [
        \   { 'line': 'カラースキーム一覧' , 'url': 'http://colorswat.ch/vim/list?p=2&o=star' },
        \   { 'line': 'カラースキーム一覧' , 'url': 'http://vimcolors.com/' },
        \   { 'line': 'Nerd Fonts チートシート' , 'url': 'https://www.nerdfonts.com/cheat-sheet' },
        \ ]

  for el in l:res
    if has_key(el, 'url')
      let el.line ..= ' : ' .. el.url
      let el.cmd = ':OpenBrowser ' .. el.url
      unlet el.url
    endif
  endfor

  return l:res
endfunction


let g:startify_commands = [
      \   ':echo "hi"',
      \   ':call dein#recache_runtimepath()',
      \   ':call dein#check_update()',
      \   ':call dein#build()',
      \   ':call dein#remote_plugins()',
      \   ':DeinClean',
      \   ':CocConfig',
      \   ':History',
      \   ':Colors',
      \ ]

let g:startify_lists = [
      \ { 'type': 'commands',  'header': ["   \uf489 コマンド"] },
      \ { 'type': function('s:MyColorSelections'),  'header': ["   \u26a1 カラーテーマ"] },
      \ { 'type': function('s:MyRefs'),  'header': ["   \uf002 リファレンス"] },
      \ { 'type': function('s:MyLinks'),  'header': ["   \u26a1 便利リンク"] },
      \ ]

nnoremap <silent> ,s :<C-u>Startify \| only<CR>
'''
hook_post_source = '''
augroup init_vim
  au User StartifyReady silent! nunmap <buffer> q
  au User StartifyReady silent! nunmap <buffer> q
  au User StartifyReady silent! nunmap <buffer> t
  au User StartifyReady silent! nunmap <buffer> T
  au User StartifyReady silent! nunmap <buffer> T
augroup END
'''
# --------------

[[plugins]]
if = "has('nvim')"
repo = 'LumaKernel/nvim-visual-eof.lua'
hook_post_source ='''
lua require'visual-eof'.setup { hl_EOL = 'NonText'; }
'''

[[plugins]]
# :StripWhitespace
repo = 'ntpeters/vim-better-whitespace'
hook_add = '''
let g:better_whitespace_enabled = 1
let g:strip_whitespace_on_save = 0
let g:strip_max_file_size = 5000
'''

[[plugins]]
repo = 'relastle/vim-nayvy'
hook_add = '''
let g:nayvy_import_path_format = 'all_absolute'
'''

[[plugins]]
repo = 'wakatime/vim-wakatime'
if = '!IsPrivateMode()'

[[plugins]]
repo = 'sentriz/vim-print-debug'
hook_add = '''
function! s:my_print_debug() abort
  if exists('t:print_debug_current_nr')
    if t:print_debug_current_nr >= 96 + 26
      let t:print_debug_current_nr = 96
    endif
  endif
  if !&modifiable
    echohl WarningMsg
    echomsg "[my print debug] not modifiable..."
    echohl None
    return
  endif
  call print_debug#print_debug()
endfunction

nnoremap <Space>p :<C-u>call <SID>my_print_debug()<CR>

let g:my_debug_style = [
  \   'color:red',
  \   'background:black',
  \   'display:inline-block',
  \   'padding:0.2em',
  \   'font-size:1em',
  \ ]
call map(g:my_debug_style, {_, v -> printf("%s !important;", v)})
let g:my_debug_style = join(g:my_debug_style, '')

let g:my_html_print_debug = printf('<span style="%s">_x_[XXX]_x_: {}</span>', g:my_debug_style)

let g:print_debug_templates = {
  \   'go':              'fmt.Printf("_x_[XXX]_x_ {}\n")',
  \   'python':          'logging.error(f"_x_[XXX]_x_ {}")',
  \   'javascript':      'console.log(`_x_[XXX]_x_ {}`);',
  \   'javascriptreact': 'console.log(`_x_[XXX]_x_ {}`);',
  \   'typescript':      'console.log(`_x_[XXX]_x_ {}`);',
  \   'typescriptreact': 'console.log(`_x_[XXX]_x_ {}`);',
  \   'vue':             'console.log(`_x_[XXX]_x_ {}`);',
  \   'svelte':          'console.log(`_x_[XXX]_x_ {}`);',
  \   'c':               'printf(_x_[XXX]_x_ {}\n");',
  \   'cpp':             'std::cout << ("_x_[XXX]_x_ {}\n") << std::endl;',
  \   'html':            g:my_html_print_debug,
  \   'htmldjango':      g:my_html_print_debug,
  \   'rust':            'println!("_x_[XXX]_x_ {}");',
  \ }
'''

[[plugins]]
repo = 'Xuyuanp/scrollbar.nvim'
hook_add = '''
augroup my_config_scrollbar_nvim
  autocmd!
  let s:sc_show = "silent! lua require('scrollbar').show()"
  let s:sc_clear = "silent! lua require('scrollbar').clear()"
  exe "autocmd BufEnter    *" s:sc_show
  exe "autocmd BufLeave    *" s:sc_clear

  exe "autocmd CursorMoved *" s:sc_show
  exe "autocmd VimResized  *" s:sc_show

  exe "autocmd FocusGained *" s:sc_show
  exe "autocmd FocusLost *" s:sc_clear
augroup end

let g:scrollbar_shape = {
  \ 'head': '+',
  \ 'body': '|',
  \ 'tail': '+',
  \ }

function! ClearScrollBar() abort
silent! lua require('scrollbar').clear()
endfunction

command! ClearScrollBar call ClearScrollBar()

nnoremap <silent> <SPACE><SPACE> :<C-u>ClearScrollBar<CR>
'''

[[plugins]]
if = 1
repo = 'pantharshit00/vim-prisma'

[[plugins]]
if = "g:ts_lsp_mode is# 'tsu'"
repo = 'Quramy/tsuquyomi'
hook_add = '''
let g:tsuquyomi_disable_quickfix = 1
'''

[[plugins]]
repo = 'jparise/vim-graphql.git'
if = '!has("nvim")'

[[plugins]]
repo = 'kamykn/spelunker.vim'
hook_add = '''
let &spellfile = expand('$HOME/dotfiles/vim/spellfile.utf-8.add')
let g:spelunker_spell_bad_group = 'Warning'
let g:spelunker_complex_or_compound_word_group = 'Warning'

let g:spelunker_disable_auto_group = 1

function! SpelunkerInit(...) abort
  if line('$') < 2000
    call spelunker#check()
  endif
endfunction

augroup spelunker
  autocmd!
  autocmd BufWinEnter,BufWritePost * call SpelunkerInit()
  autocmd FileType * call SpelunkerInit()
  autocmd BufWinEnter,BufWritePost * call timer_start(1000 * 2, function('SpelunkerInit'))
augroup END
'''

[[plugins]]
repo = 'kamykn/popup-menu.nvim'

[[plugins]]
depends = ["deoplete.nvim"]
repo = 'Shougo/deoplete-nextword'

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
if = 'has("nvim")'
on_ft = [
  'javascript',
  'javascriptreact',
  'typescript',
  'typescriptreact',
  'rust',
  'go',
  'c',
  'cpp',
  'elm',
  'teal',
  'java',
  'dart',
  'lua',
  'ocaml',
  'json',
  'jsdoc',
  'html',
  'nix',
  'kotlin',
  'ocamllex',
  'vue',
  'scala',
  'toml',
  'bash',
  'php',
  'graphql',
  'python',
  'yaml',
  'css',
]
on_cmd = [
  "TSBufDisable",
  "TSBufEnablescript",
  "TSConfigInfo",
  "TSDisableAll",
  "TSEnableAll",
  "TSInstal",
  "TSInstallFromGrammar",
  "TSInstallInfo",
  "TSInstallSync",
  "TSModuleInfo",
  "TSUninstall",
  "TSUpdate",
]
hook_add = '''
set foldmethod=expr
set foldexpr=nvim_treesitter#foldexpr()
'''
hook_post_source = '''
lua <<EOF
  require'nvim-treesitter.configs'.setup {
    ensure_installed = "all",
    indent = {
      enable = true,
    },
    highlight = {
      enable = true,
    },
  }
  local parser_config = require "nvim-treesitter.parsers".get_parser_configs()
  -- parser_config.prisma = {
  --   install_info = {
  --     url = "~/workspace/tree-sitter-prisma",
  --     files = {"src/parser.c"},
  --   },
  --   filetype = "prisma",
  -- }
EOF
'''

[[plugins]]
repo = 'evanleck/vim-svelte'
on_path = '\.svelte$'
rev = 'main'

[[plugins]]
repo = 'Yggdroot/indentLine'
hook_add = '''
let g:indentLine_setConceal = 0
'''

[[plugins]]
repo = 'vim-denops/denops.vim'
# let g:denops#debug = 1

[[plugins]]
repo = 'luma-dev/dps-godoc'

[[plugins]]
repo = 'LumaKernel/as-it-is.vim'
